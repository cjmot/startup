
**AWS Server**
- Not as hard to create as I imagined
- ssh keys stored as a file
- ssh -i production.pem ubuntu@shopkingsland.click

**Caddy** 
- Caddy is a web service that listens for incoming HTTP requests
- Caddy is used to serve application
- __Important Caddy files__:
  - Configuration file - Contains the definitions for routing HTTP requests that Caddy receives. This is used to determine the location where static HTML files are loaded from, and also to proxy requests into the services you will create later.
  - HTML file = This is the directory of files that Caddy serves up when requests are made to the root or your web server.

1/24/2024
**Domain Name registration**
- https://github.com/webprogramming260/.github/blob/main/profile/webServers/amazonWebServicesRoute53/amazonWebServicesRoute53.md
- route 53 in aws to create domain, once there, create 2 new records, one for the domain, one for subdomains.

**HTTPS**
- HTTP = non-secure hypertext transport protocol
- HTTPS = secure Hypertext Transport Protocol
  - just http but with negotiated secure connection that happens before data is exchanged.
  - Secure connection means all data is encrypted using __TLS protocol__.

**TLS**
- tls (aka SSL, less secure predecessor) works by negotiating a shared secret that is then used to encrypt data.
  - curl -v in device console shows actual negotiation, /dev/null redirection throws away actual http response
  - Core piece of tls handshake is exchange of web certificate that identifies the domain name of the server creating the secure connection
  - browser will compare the certificate domain name ot the one represented in the url and if they don't match, or the certificate is invalid or out of date, will display a massive warning.

**Web certificates**
- Generated by trusted 3rd party using public/private key encryption
- issuer responsible for verifying that certificate owner actually owns the domain name represented by certificate
- once there is certificate for your domain name, can serve certificate from your web server then the browser can validate certificate by using the public keys of the certificate issuer.
- used to cost hundreds of dollars a year to get web certificate, but small nonprofit called __Let's Encrypt__ started creating trusted web certificates for free.
  - Broke monopoly that trusted web certificate issuers had on industry
  - Now anyone who owns a domain name can dynamically generate and renew a certificate for free. 
  - __Let's Encrypt__ made the web safer and more reliable for everyone
  - Caddy uses Let's Encrypt to generate a web certificate every time an HTTPS request is made for a domain name that Caddy does not have a web certificate for.
  - ![img.png](img.png)

**Enabling HTTPS**
- Modern browsers expect web servers to exclusively use HTTPS for all communication.
- next version of HTTP(v3) only supports secure connections. - you should always support HTTPS for any web application that you build.
- obtain and renew web certificates by enabling ACME protocol for you web server and communicating with Let's Encrypt to generate the needed certificates.

**More Caddy**
- Caddy has ACME support built into it by default, all you need to do is configure caddy with the domain name for your web server. 
- go into ubuntu, change file so the :80 and references to domain name are the domain name, then save (esc, then :wq), then restart caddy (sudo service caddy restart)

**The Console**
- console window aka command line, shell, or terminal.
  - Essential web development tool.
  - provides access to the file system and allows for the execution of command line applications.
  - many to choose from, all OS come with a default. but for the best one installation needed.
- __Console Application__
  - must be POSIX compliant - supports standard set of console commands. 
    - mac and linux support POSIX
    - Windows needs git bash
    - don't use git command, cmd, or powershell.
- __Simple Commands__
  - __echo__ - Output the parameters of the command
  - __cd__ - Change directory
  - __mkdir__ - Make directory
  - __rmdir__ - Remove directory
  - __rm__ - Remove file(s)
  - __mv__ - Move file(s)
  - __cp__ - Copy files
  - __ls__ - List files
  - __curl__ - Command line client URL browser
  - __grep__ - Regular expression search
  - __find__ - Find files
  - __top__ - View running processes with CPU and memory usage
  - __df__ - View disk statistics
  - __cat__ - Output the contents of a file
  - __less__ - Interactively output the contents of a file
  - __wc__ - Count the words in a file
  - __ps__ - View the currently running processes
  - __kill__ - Kill a currently running process
  - __sudo__ - Execute a command as a super user (admin)
  - __ssh__ - Create a secure shell on a remote computer
  - __scp__ - Securely copy files to a remote computer
  - __history__ - Show the history of commands
  - __ping__ - Check if a website is up
  - __tracert__ - Trace the connections to a website
  - __dig__ - Show the DNS information for a domain
  - __man__ - Look up a command in the manual
- Chaining commands:
  - __|__ Take the output from the command on the left and pipe, or pass, it to the command on the right
  - __>__ redirect output to a file. Overwrites file if it exists
  - __>>__ redirect output to a file. Appends if the file exists
  - ex. 
    - ls -l | grep ' Nov ' | wc -l  - lists files in a directory, pips it into grep to search for files created in Nov, and then pip that into wc to count the number of files found with a date of Nov.
- CTRL-R - use type ahead to find previous commands
- CTRL-C - Kill the currently running command

**Important CSS Info**
- Look at cs260 GitHub for details
- https://codepen.io/ hub for cool css styles and animation
- Importing fonts:
  - @font-face {
    - font-family: 'Quicksand';
    - src: url("")
  - }
  - p {
    - font-family: Quicksand;
  - }
- If you don't want to host font files:
  - @import url('https://fonts.googleapis.com/css2?family=Rubik Microbe&display=swap');

**CSS**
- <meta name="viewport" content="width=device-width,initial-scale=1"/> located in head element, tells browser not to scale page
- float allows inline elements to wrap around it
- Different frameworks allowed, most popular bootstrap and tailwind gaining popularity

**JavaScript**
- I already know JS basics, nothing new here

**JSON**
- JavaScript Object Notation
- Provides a simple and effective way to share and store data.
- Most often Json docs contain objects. objects contain 0 or more key value pairs. Key always string, and value must be one of teh valid JSON data types. key value paris delimited with commas. 
```JSON
{
  "class": {
  "title": "web programming",
  "description": "Amazing"
  },
  "enrollment": ["Marco", "Jana", "فَاطِمَة"],
  "start": "2025-02-01",
  "end": null
  }
```
- can convert JSON to, and from JS using JSON.parse and JSON.stringify functions
```js
  const obj = { a: 2, b: 'crockford', c: undefined };
  const json = JSON.stringify(obj);
  const objFromJson = JSON.parse(json);

  console.log(obj, json, objFromJson);

  // OUTPUT:
  // {a: 2, b: 'crockford', c: undefined}
  // {"a":2, "b":"crockford"}
  // {a: 2, b: 'crockford'}
```
- JSON cannot represent undefined object, and gets dropped when converting from JS to JSON

***JS object and classes***
- objects represent collection of name value pairs referred to as properties. 
  - property names must be of type String or Symbol, but value can be of any type. 
  - Objects also can have functionality like constructors, this pointer, static properties and functions, and inheritance.
  - Created with new operator. causes object's constructor to be called. once declared you can add properties to object by simply referencing property name in an assignment. Any type of variable can be assigned to a property. includes sub-object, array, or function. 
  - properties can be referenced either with dot (obj.prop) or bracket notation (obj.['prop']).
```js
const obj = new Object({ a: 3 });
obj['b'] = 'fish';
obj.c = [1, 2, 3];
obj.hello = function () {
  console.log('hello');
};

console.log(obj);
// OUTPUT: {a: 3, b: 'fish', c: [1,2,3], hello: func}
```
  - object can refer to the standard JS objects (eg. Promise, Map, Object, Function, Date, ...), or can refer specifically to JS Object (ie. new Object() ) or can refer to any JS object you create (e.g. {a:'a', b:2}) overload usage can be confusing
**Object-literals**
- can also declare a variable of object type with the object literal syntax. allows you to provide initial composition of the object.
```js
const obj = {
    a: 3,
    b: 'fish',
};
```
**Object functions**
- several interesting static functions associated with it:
  - entries: returns an array of key value pairs
  - keys: returns array of keys
  - values: returns array of values
```js
const obj = {
  a: 3,
  b: 'fish',
};

console.log(Object.entries(obj));
// OUTPUT: [['a', 3], ['b', 'fish']]
console.log(Object.keys(obj));
// OUTPUT: ['a', 'b']
console.log(Object.values(obj));
// OUTPUT: [3, 'fish']
```
**Constructor**
- any function that returns an object is considered a constructor and can be invoked with the new operator

**Classes**
- classes define objects. Using a class clarifies the intent to create a reusable component rather than a one-of object. Class declarations look similar to declaring an object, but classes have an explicit constructor and assumed function declarations.
- You can make properties and functions of classes private by prefixing them with a #.
```js
class Person {
    #name;
    constructor(name){
        this.#name = name;
    }
}
const p = new Person('Eich');
p.#name = 'Lie';
// OUTPUT: Uncaught SyntaxError: Private field '#name' must be declared in an enclosing class
```

***Inheritance***
- classes can be extended by using the extends keyword to define inheritance. Parameters that need to be passed to the parent class are delivered using the super function. Any functions defined on the child that have the same name as the parent override the parent's implementation. A parent's function can be explicitly accessed using the super keyword.
```js
class Employee extends Person {
  constructor(name, position) {
    super(name);
    this.position = position;
  }

  print() {
    return super.print() + '. I am a ' + this.position;
  }
}

const e = new Employee('Eich', 'programmer');
console.log(e.print());
// OUTPUT: My name is Eich. I am a programmer
```

***REGEX***
- regex support built right into JS. 
- you can create regex using the class constructor or a regex literal
```js
const objRegex = new RegExp('ab*', 'i');
const literalRegex = /ab*/i;
```
- string class has several functions that accept regex. 
  - match, replace, search, and split
```js
const petRegex = /(dog)|(cat)|(bird)/gim;
const text = 'Both cats and dogs are pets, but not rocks.';

text.match(petRegex);
// RETURNS: ['cat', 'dog']

text.replace(petRegex, 'animal');
// RETURNS: Both animals and animals are pets, but not rocks.

petRegex.test(text);
// RETURNS: true
```

***Rest***
- parameter that contains the rest of the parameters
```js
function hasNumber(test, ...numbers) {
    return numbers.some((i) => i === test);
}
hasNumber(2, 1, 2, 3);
// RETURNS: true
```
***Spread***
- opposite of rest. Takes an object that is iterable and expands it into a function's parameters.
```js
function person(firstName, lastName){
    return { first: firstName, last: lastName};
}

const p = person(...['Ryan', 'Dahl']);
console.log(p);
// OUTPUT: {first: 'Ryan', last: 'Dahl'}
```
***Exceptions***
- JS supports handling using try catch and throw syntax. exception can be triggered whenever your code generates an exception using the throw keyword, or whenever an exception is generated by the GS runtime, for example, when an undefined variable is used.
```js
function connectDatabase() {
  throw new Error('connection error');
}

try {
  connectDatabase();
  console.log('never executed');
} catch (err) {
  console.log(err);
} finally {
  console.log('always executed');
}

// OUTPUT: Error: connection error
//         always executed
```
- Throwing exceptions should only happen when something truly exceptional occurs. For ex. file not found exception when file is required for code to run, such as a required config file. code will be easier to debug, and logs more meaningful if you restrict exceptions to truly exceptional situations

***Fallbacks***
- commonly implemented using exception handling.
- put the normal feature path in a try block and provide a fallback implementation in the catch block. 
  - ex normally you would get the high scores for a game by making a network request, but if the network is not available then a locally cached version of the last available scores is used.
- by providing fallback, you can always return something, even if the desired feature is temporarily unavailable.

***Destructuring***
- not destructing
- process of pulling individual items out of an existing one, or removing structure. You can do this with either arrays or objects. helpful when you only care about a few items in the original structure.
- examples:
```js
const [b, c, ...others] = a;

console.log(b, c, others);
// OUTPUT: 1, 2, [4,5]
```

```js
const o = { a: 1, b: 'animals', c: ['fish', 'cats'] };

const { a, c } = o;

console.log(a, c);
// OUTPUT 1, ['fish', 'cats']
```

```js
const o = { a: 1, b: 'animals', c: ['fish', 'cats'] };

const { a: count, b: type } = o;

console.log(count, type);
// OUTPUT 1, animals
```

```js
const { a, b = 22 } = {};
const [c = 44] = [];

console.log(a, b, c);
// OUTPUT: undefined, 22, 44
```

```js
let a = 22;

[a] = [1, 2, 3];

console.log(a);
// OUTPUT: 1
```

***Scope***
- Global - Visible to all code
- Module - Visible to all code running in a module
- Function - Visible within a function
- Block - Visible within a block of code delimited by curly braces

- **Var**
  - ignores block scope
  - always logically hoisted to the top of the function
  - Use ```const``` and ```let``` unless you fully understand why you are using var

- **This**
  - value of ```this``` depends on the context in which it is referenced.
  - 3 contexts:
    - **Global** - when outside a function or object it refers to the ```globalThis``` object, which represents the context for runtime environment
    - **Function** - when inside a function refers to the object that owns the function. either an object you defined or ```globalThis``` if function is outside an object
    - **Object** - when inside an object refers to the object
- **Closure**
  - defined as a function and its surrounding state
  - whatever variables are accessible when a function is created are available inside that function. Holds true even if you pass the function outside the scope of its original creation.
  - ex of function created as part of an object. means that function has access to the object's this pointer
```js
globalThis.x = 'global';

const obj = {
    x: 'object',
    f: function () {
        console.log(this.x);
    },
};

obj.f();
// OUTPUT: object
```
  - arrow functions work different
```js
globalThis.x = 'global';

const obj = {
  x: 'object',
  f: () => console.log(this.x),
};

obj.f();
// OUTPUT: global
```
  - but if we make the function return an arrow function, then this pointer will the object's this pointer since that was the active context at the time the arrow function was created.
```js
globalThis.x = 'global';

const obj = {
  x: 'object',
  make: function () {
    return () => console.log(this.x);
  },
};

const f = obj.make();
f();
// OUTPUT: object
```

***JavaScript Modules***
- allow for the partitioning and sharing of code. 
- node.js, a server side JS execution app introduced the concept to support importing of packages of JS from third party providers
- node.js modules called CommonJS modules, JS modules called ES modules
- modules create file-based scope for the code they represent, therefore you must explicitly export the objects from one file and then import them into another file.
```js
export function alertDisplay(msg){
    alert(msg);
}
```
```js
import { alertDisplay } from './alert.js';

alertDisplay('called from main.js');
```
***ES modules in browser***
- more complicated.
- modules can only be called from other modules
- you can import modules from html
```html
<script type="module">
  import { alertDisplay } from './alert.js';
  alertDisplay('module loaded');
</script>
```
- if you want to put it in global scope, add it into the window object
```html
<html>
  <body>
    <script type="module">
      import { alertDisplay } from './alert.js';
      window.btnClick = alertDisplay;

      document.body.addEventListener('keypress', function (event) {
        alertDisplay('Key pressed');
      });
    </script>
    <button onclick="btnClick('button clicked')">Press me</button>
  </body>
</html>
```
***Modules with web frameworks***
- usually no need to worry about differentiating between global and ES module scope.

***Document Object Model***
- object representation of the HTML elements that the browser uses to render the display.
- browser also exposes the DOM to external code so that you can write programs that dynamically manipulate the HTML.
- browser that provides access to the DOM through a global variable name ```document``` that points to the root element of the DOM.
  - If you open the browser's debugger console window and type the variable name ```document``` you will see the DOM for the document the browser is currently rendering

***Accessing the DOM***
- Every element in an HTML document implements the DOM element interface, which is derived from the DOM Node interface.
- **DOM Element Interface** provides the means for iterating child elements, accessing the parent element, and manipulating the element's attributes. For your JS code, you can start with the document variable and walk through the every element in the tree.
```js
function displayElement(el) {
    console.log(el.tagName);
    for (const child of el.children) {
        displayElement(child);
    }
}

displayElement(document);
```
- provide a CSS selector to the ```querySelectorAll``` function in order to select elements from the document. The ```textContent``` property contains all of the element's text. 
- you can even access a textual representation of an element's HTML content with the ```innerHTML``` property.
```js
const listElements = document.querySelectorAll('p');
for (const el of listElements) {
    console.log(el.textContent);
}
```
***Modifying the DOM***
- DOM supports the ability to insert, modify, or delete the elements in the DOM. 
- To create a new element you first create the element on the DOM document
- then insert the new element into DOM tree by appending it to an existing element in the tree
```js
function insertChild(parentSelector, text) {
    const newChild  = document.createElement('div');
    newChild.textContent = text;
    
    const parentElement = document.querySelector(parentSelector);
    parentElement.appendChild(newChild);
}

insertChild('#courses', 'new course');
```
- to delete elements call the removeChild function on the parent element.
```js
function deleteElement(elementSelector) {
    const el = document.querySelector(elementSelector);
    el.parentElement.removeChild(el);
}

deleteElement('#courses div');
```

***Injecting HTML***
- DOM also allows you to inject entire blocks of HTML into an element. 
- following code finds first div element in DOM and replaces all the HTML it contains
```js
const el = document.querySelector('div');
el.innerHTML = '<div class="injected"><b>Hello</b>!</div>';
```
- however, directly injecting HTML as a block of text is common attack vector for hackers. 
- if untrusted party can inject JavaScript anywhere in your application then that JS can represent itself as the current user of the application. The attacker can then make requests for sensitive data, monitor activity, and steal credentials.
- Ex below shows how the img element can be used to launch an attack as soon as the page is loaded.
```html
<img src="bogus.png" onerror="console.log('All your base are belong to us')" />
```
- if you are injecting HTML, make sure that it cannot be manipulated by a user. Common injection paths include HTML input controls, URL parameters, and HTTP headers.
- Either sanitize any HTML that contains variables, or simply use DOM manipulation functions instead of using ```innerHTML```

***Event Listeners***
- All DOM elements support the ability to attach a function that gets called when an event occurs on the element. (Event listeners)
- ex:
```js
const submitDataEl = document.querySelector('#submitData');
submitDataEl.addEventListeneer('click', function (event) {
    console.log(event.type);
});
```
- lots of possible events you can add a listener to. includes things like mouse, keyboard, scrolling, animation, video, audio, WebSocket, and clipboard events. 
- Commonly used events:
  - clipboard - cut, copied, pasted
  - focus - an element gets focus
  - keyboard - keys are pressed
  - mouse - click events
  - text selection - when text is selected
- you can add event listeners directly in HTML
```html
<button onclick='alert("clicked")'>click me</button>
```

***Local Storage***
- ```localStorage``` api provides ability to persistently store and retrieve data (ie scores, usernames, etc.) on a user's browser across user sessions and HTML page renderings.
- your frontend JS code could store a user's name on one HTML page, and then retrieve the name later when a different HTML page is loaded.
- same user's name will also be available in local storage the next time the same browser is used to access the same website.
- Also used as a cache for when data cannot be obtained from the server. 
  - ex. frontend JS could store the last high scores obtained from the service, and then display those scores in the future if the service not available.
- four main functions:
  - setItem(name, value) = sets a named item's value into local storage
  - getItem(name) = gets a named item's value from local storage
  - removeItem(name) = removes a named item from local storage
  - clear() = clears all items in local storage.
- objects and arrays need to be converted to a json string using JSON.stringify() on insertion, and JSON.parse() when retrieved.
- in devtools, Application, then Storage > local storage and then your domain name will let you add, view, update, and delete any storage values

***Promise***
- long running or blocking tasks should be executed with the use of JS ```Promise```. 
- allows main rendering thread to continue while some action is executed in background.
- make promise by calling Promise object constructor and passing it an executor function that runs the asynchronous operation.
  - asynchronously means that promise constructor may return before the promise executor function runs.
  - state of promise execution is always in one of three states.
    - pending - running asynchronously
    - fulfilled - completed successfully
    - rejected = failed to complete
- **Resolving and rejecting**
  - 