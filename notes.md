
**AWS Server**
- Not as hard to create as I imagined
- ssh keys stored as a file
- ssh -i production.pem ubuntu@shopkingsland.click

**Caddy** 
- Caddy is a web service that listens for incoming HTTP requests
- Caddy is used to serve application
- __Important Caddy files__:
  - Configuration file - Contains the definitions for routing HTTP requests that Caddy receives. This is used to determine the location where static HTML files are loaded from, and also to proxy requests into the services you will create later.
  - HTML file = This is the directory of files that Caddy serves up when requests are made to the root or your web server.

1/24/2024
**Domain Name registration**
- https://github.com/webprogramming260/.github/blob/main/profile/webServers/amazonWebServicesRoute53/amazonWebServicesRoute53.md
- route 53 in aws to create domain, once there, create 2 new records, one for the domain, one for subdomains.

**HTTPS**
- HTTP = non-secure hypertext transport protocol
- HTTPS = secure Hypertext Transport Protocol
  - just http but with negotiated secure connection that happens before data is exchanged.
  - Secure connection means all data is encrypted using __TLS protocol__.

**TLS**
- tls (aka SSL, less secure predecessor) works by negotiating a shared secret that is then used to encrypt data.
  - curl -v in device console shows actual negotiation, /dev/null redirection throws away actual http response
  - Core piece of tls handshake is exchange of web certificate that identifies the domain name of the server creating the secure connection
  - browser will compare the certificate domain name ot the one represented in the url and if they don't match, or the certificate is invalid or out of date, will display a massive warning.

**Web certificates**
- Generated by trusted 3rd party using public/private key encryption
- issuer responsible for verifying that certificate owner actually owns the domain name represented by certificate
- once there is certificate for your domain name, can serve certificate from your web server then the browser can validate certificate by using the public keys of the certificate issuer.
- used to cost hundreds of dollars a year to get web certificate, but small nonprofit called __Let's Encrypt__ started creating trusted web certificates for free.
  - Broke monopoly that trusted web certificate issuers had on industry
  - Now anyone who owns a domain name can dynamically generate and renew a certificate for free. 
  - __Let's Encrypt__ made the web safer and more reliable for everyone
  - Caddy uses Let's Encrypt to generate a web certificate every time an HTTPS request is made for a domain name that Caddy does not have a web certificate for.
  - ![img.png](img.png)

**Enabling HTTPS**
- Modern browsers expect web servers to exclusively use HTTPS for all communication.
- next version of HTTP(v3) only supports secure connections. - you should always support HTTPS for any web application that you build.
- obtain and renew web certificates by enabling ACME protocol for you web server and communicating with Let's Encrypt to generate the needed certificates.

**More Caddy**
- Caddy has ACME support built into it by default, all you need to do is configure caddy with the domain name for your web server. 
- go into ubuntu, change file so the :80 and references to domain name are the domain name, then save (esc, then :wq), then restart caddy (sudo service caddy restart)

**The Console**
- console window aka command line, shell, or terminal.
  - Essential web development tool.
  - provides access to the file system and allows for the execution of command line applications.
  - many to choose from, all OS come with a default. but for the best one installation needed.
- __Console Application__
  - must be POSIX compliant - supports standard set of console commands. 
    - mac and linux support POSIX
    - Windows needs git bash
    - don't use git command, cmd, or powershell.
- __Simple Commands__
  - __echo__ - Output the parameters of the command
  - __cd__ - Change directory
  - __mkdir__ - Make directory
  - __rmdir__ - Remove directory
  - __rm__ - Remove file(s)
  - __mv__ - Move file(s)
  - __cp__ - Copy files
  - __ls__ - List files
  - __curl__ - Command line client URL browser
  - __grep__ - Regular expression search
  - __find__ - Find files
  - __top__ - View running processes with CPU and memory usage
  - __df__ - View disk statistics
  - __cat__ - Output the contents of a file
  - __less__ - Interactively output the contents of a file
  - __wc__ - Count the words in a file
  - __ps__ - View the currently running processes
  - __kill__ - Kill a currently running process
  - __sudo__ - Execute a command as a super user (admin)
  - __ssh__ - Create a secure shell on a remote computer
  - __scp__ - Securely copy files to a remote computer
  - __history__ - Show the history of commands
  - __ping__ - Check if a website is up
  - __tracert__ - Trace the connections to a website
  - __dig__ - Show the DNS information for a domain
  - __man__ - Look up a command in the manual
- Chaining commands:
  - __|__ Take the output from the command on the left and pipe, or pass, it to the command on the right
  - __>__ redirect output to a file. Overwrites file if it exists
  - __>>__ redirect output to a file. Appends if the file exists
  - ex. 
    - ls -l | grep ' Nov ' | wc -l  - lists files in a directory, pips it into grep to search for files created in Nov, and then pip that into wc to count the number of files found with a date of Nov.
- CTRL-R - use type ahead to find previous commands
- CTRL-C - Kill the currently running command

**Important CSS Info**
- Look at cs260 GitHub for details
- https://codepen.io/ hub for cool css styles and animation
- Importing fonts:
  - @font-face {
    - font-family: 'Quicksand';
    - src: url("")
  - }
  - p {
    - font-family: Quicksand;
  - }
- If you don't want to host font files:
  - @import url('https://fonts.googleapis.com/css2?family=Rubik Microbe&display=swap');

**CSS**
- <meta name="viewport" content="width=device-width,initial-scale=1"/> located in head element, tells browser not to scale page
- float allows inline elements to wrap around it
- Different frameworks allowed, most popular bootstrap and tailwind gaining popularity

**JavaScript**
- I already know JS basics, nothing new here

**JSON**
- JavaScript Object Notation
- Provides a simple and effective way to share and store data.
- Most often Json docs contain objects. objects contain 0 or more key value pairs. Key always string, and value must be one of teh valid JSON data types. key value paris delimited with commas. 
```JSON
{
  "class": {
  "title": "web programming",
  "description": "Amazing"
  },
  "enrollment": ["Marco", "Jana", "فَاطِمَة"],
  "start": "2025-02-01",
  "end": null
  }
```
- can convert JSON to, and from JS using JSON.parse and JSON.stringify functions
```js
  const obj = { a: 2, b: 'crockford', c: undefined };
  const json = JSON.stringify(obj);
  const objFromJson = JSON.parse(json);

  console.log(obj, json, objFromJson);

  // OUTPUT:
  // {a: 2, b: 'crockford', c: undefined}
  // {"a":2, "b":"crockford"}
  // {a: 2, b: 'crockford'}
```
- JSON cannot represent undefined object, and gets dropped when converting from JS to JSON

***JS object and classes***
- objects represent collection of name value pairs referred to as properties. 
  - property names must be of type String or Symbol, but value can be of any type. 
  - Objects also can have functionality like constructors, this pointer, static properties and functions, and inheritance.
  - Created with new operator. causes object's constructor to be called. once declared you can add properties to object by simply referencing property name in an assignment. Any type of variable can be assigned to a property. includes sub-object, array, or function. 
  - properties can be referenced either with dot (obj.prop) or bracket notation (obj.['prop']).
```js
const obj = new Object({ a: 3 });
obj['b'] = 'fish';
obj.c = [1, 2, 3];
obj.hello = function () {
  console.log('hello');
};

console.log(obj);
// OUTPUT: {a: 3, b: 'fish', c: [1,2,3], hello: func}
```
  - object can refer to the standard JS objects (eg. Promise, Map, Object, Function, Date, ...), or can refer specifically to JS Object (ie. new Object() ) or can refer to any JS object you create (e.g. {a:'a', b:2}) overload usage can be confusing
**Object-literals**
- can also declare a variable of object type with the object literal syntax. allows you to provide initial composition of the object.
```js
const obj = {
    a: 3,
    b: 'fish',
};
```
**Object functions**
- several interesting static functions associated with it:
  - entries: returns an array of key value pairs
  - keys: returns array of keys
  - values: returns array of values
```js
const obj = {
  a: 3,
  b: 'fish',
};

console.log(Object.entries(obj));
// OUTPUT: [['a', 3], ['b', 'fish']]
console.log(Object.keys(obj));
// OUTPUT: ['a', 'b']
console.log(Object.values(obj));
// OUTPUT: [3, 'fish']
```
**Constructor**
- any function that returns an object is considered a constructor and can be invoked with the new operator

**Classes**
- classes define objects. Using a class clarifies the intent to create a reusable component rather than a one-of object. Class declarations look similar to declaring an object, but classes have an explicit constructor and assumed function declarations.
- You can make properties and functions of classes private by prefixing them with a #.
```js
class Person {
    #name;
    constructor(name){
        this.#name = name;
    }
}
const p = new Person('Eich');
p.#name = 'Lie';
// OUTPUT: Uncaught SyntaxError: Private field '#name' must be declared in an enclosing class
```

***Inheritance***
- classes can be extended by using the extends keyword to define inheritance. Parameters that need to be passed to the parent class are delivered using the super function. Any functions defined on the child that have the same name as the parent override the parent's implementation. A parent's function can be explicitly accessed using the super keyword.
```js
class Employee extends Person {
  constructor(name, position) {
    super(name);
    this.position = position;
  }

  print() {
    return super.print() + '. I am a ' + this.position;
  }
}

const e = new Employee('Eich', 'programmer');
console.log(e.print());
// OUTPUT: My name is Eich. I am a programmer
```

***REGEX***
- regex support built right into JS. 
- you can create regex using the class constructor or a regex literal
```js
const objRegex = new RegExp('ab*', 'i');
const literalRegex = /ab*/i;
```
- string class has several functions that accept regex. 
  - match, replace, search, and split
```js
const petRegex = /(dog)|(cat)|(bird)/gim;
const text = 'Both cats and dogs are pets, but not rocks.';

text.match(petRegex);
// RETURNS: ['cat', 'dog']

text.replace(petRegex, 'animal');
// RETURNS: Both animals and animals are pets, but not rocks.

petRegex.test(text);
// RETURNS: true
```

***Rest***
- parameter that contains the rest of the parameters
```js
function hasNumber(test, ...numbers) {
    return numbers.some((i) => i === test);
}
hasNumber(2, 1, 2, 3);
// RETURNS: true
```
***Spread***
- opposite of rest. Takes an object that is iterable and expands it into a function's parameters.
```js
function person(firstName, lastName){
    return { first: firstName, last: lastName};
}

const p = person(...['Ryan', 'Dahl']);
console.log(p);
// OUTPUT: {first: 'Ryan', last: 'Dahl'}
```
***Exceptions***
- JS supports handling using try catch and throw syntax. exception can be triggered whenever your code generates an exception using the throw keyword, or whenever an exception is generated by the GS runtime, for example, when an undefined variable is used.
```js
function connectDatabase() {
  throw new Error('connection error');
}

try {
  connectDatabase();
  console.log('never executed');
} catch (err) {
  console.log(err);
} finally {
  console.log('always executed');
}

// OUTPUT: Error: connection error
//         always executed
```
- Throwing exceptions should only happen when something truly exceptional occurs. For ex. file not found exception when file is required for code to run, such as a required config file. code will be easier to debug, and logs more meaningful if you restrict exceptions to truly exceptional situations

***Fallbacks***
- commonly implemented using exception handling.
- put the normal feature path in a try block and provide a fallback implementation in the catch block. 
  - ex normally you would get the high scores for a game by making a network request, but if the network is not available then a locally cached version of the last available scores is used.
- by providing fallback, you can always return something, even if the desired feature is temporarily unavailable.

***Destructuring***
- not destructing
- process of pulling individual items out of an existing one, or removing structure. You can do this with either arrays or objects. helpful when you only care about a few items in the original structure.
- examples:
```js
const [b, c, ...others] = a;

console.log(b, c, others);
// OUTPUT: 1, 2, [4,5]
```

```js
const o = { a: 1, b: 'animals', c: ['fish', 'cats'] };

const { a, c } = o;

console.log(a, c);
// OUTPUT 1, ['fish', 'cats']
```

```js
const o = { a: 1, b: 'animals', c: ['fish', 'cats'] };

const { a: count, b: type } = o;

console.log(count, type);
// OUTPUT 1, animals
```

```js
const { a, b = 22 } = {};
const [c = 44] = [];

console.log(a, b, c);
// OUTPUT: undefined, 22, 44
```

```js
let a = 22;

[a] = [1, 2, 3];

console.log(a);
// OUTPUT: 1
```

***Scope***
- Global - Visible to all code
- Module - Visible to all code running in a module
- Function - Visible within a function
- Block - Visible within a block of code delimited by curly braces

- **Var**
  - ignores block scope
  - always logically hoisted to the top of the function
  - Use ```const``` and ```let``` unless you fully understand why you are using var

- **This**
  - value of ```this``` depends on the context in which it is referenced.
  - 3 contexts:
    - **Global** - when outside a function or object it refers to the ```globalThis``` object, which represents the context for runtime environment
    - **Function** - when inside a function refers to the object that owns the function. either an object you defined or ```globalThis``` if function is outside an object
    - **Object** - when inside an object refers to the object
- **Closure**
  - defined as a function and its surrounding state
  - whatever variables are accessible when a function is created are available inside that function. Holds true even if you pass the function outside the scope of its original creation.
  - ex of function created as part of an object. means that function has access to the object's this pointer
```js
globalThis.x = 'global';

const obj = {
    x: 'object',
    f: function () {
        console.log(this.x);
    },
};

obj.f();
// OUTPUT: object
```
  - arrow functions work different
```js
globalThis.x = 'global';

const obj = {
  x: 'object',
  f: () => console.log(this.x),
};

obj.f();
// OUTPUT: global
```
  - but if we make the function return an arrow function, then this pointer will the object's this pointer since that was the active context at the time the arrow function was created.
```js
globalThis.x = 'global';

const obj = {
  x: 'object',
  make: function () {
    return () => console.log(this.x);
  },
};

const f = obj.make();
f();
// OUTPUT: object
```

***JavaScript Modules***
- allow for the partitioning and sharing of code. 
- node.js, a server side JS execution app introduced the concept to support importing of packages of JS from third party providers
- node.js modules called CommonJS modules, JS modules called ES modules
- modules create file-based scope for the code they represent, therefore you must explicitly export the objects from one file and then import them into another file.
```js
export function alertDisplay(msg){
    alert(msg);
}
```
```js
import { alertDisplay } from './alert.js';

alertDisplay('called from main.js');
```
***ES modules in browser***
- more complicated.
- modules can only be called from other modules
- you can import modules from html
```html
<script type="module">
  import { alertDisplay } from './alert.js';
  alertDisplay('module loaded');
</script>
```
- if you want to put it in global scope, add it into the window object
```html
<html>
  <body>
    <script type="module">
      import { alertDisplay } from './alert.js';
      window.btnClick = alertDisplay;

      document.body.addEventListener('keypress', function (event) {
        alertDisplay('Key pressed');
      });
    </script>
    <button onclick="btnClick('button clicked')">Press me</button>
  </body>
</html>
```
***Modules with web frameworks***
- usually no need to worry about differentiating between global and ES module scope.

***Document Object Model***
- object representation of the HTML elements that the browser uses to render the display.
- browser also exposes the DOM to external code so that you can write programs that dynamically manipulate the HTML.
- browser that provides access to the DOM through a global variable name ```document``` that points to the root element of the DOM.
  - If you open the browser's debugger console window and type the variable name ```document``` you will see the DOM for the document the browser is currently rendering

***Accessing the DOM***
- Every element in an HTML document implements the DOM element interface, which is derived from the DOM Node interface.
- **DOM Element Interface** provides the means for iterating child elements, accessing the parent element, and manipulating the element's attributes. For your JS code, you can start with the document variable and walk through the every element in the tree.
```js
function displayElement(el) {
    console.log(el.tagName);
    for (const child of el.children) {
        displayElement(child);
    }
}

displayElement(document);
```
- provide a CSS selector to the ```querySelectorAll``` function in order to select elements from the document. The ```textContent``` property contains all of the element's text. 
- you can even access a textual representation of an element's HTML content with the ```innerHTML``` property.
```js
const listElements = document.querySelectorAll('p');
for (const el of listElements) {
    console.log(el.textContent);
}
```
***Modifying the DOM***
- DOM supports the ability to insert, modify, or delete the elements in the DOM. 
- To create a new element you first create the element on the DOM document
- then insert the new element into DOM tree by appending it to an existing element in the tree
```js
function insertChild(parentSelector, text) {
    const newChild  = document.createElement('div');
    newChild.textContent = text;
    
    const parentElement = document.querySelector(parentSelector);
    parentElement.appendChild(newChild);
}

insertChild('#courses', 'new course');
```
- to delete elements call the removeChild function on the parent element.
```js
function deleteElement(elementSelector) {
    const el = document.querySelector(elementSelector);
    el.parentElement.removeChild(el);
}

deleteElement('#courses div');
```

***Injecting HTML***
- DOM also allows you to inject entire blocks of HTML into an element. 
- following code finds first div element in DOM and replaces all the HTML it contains
```js
const el = document.querySelector('div');
el.innerHTML = '<div class="injected"><b>Hello</b>!</div>';
```
- however, directly injecting HTML as a block of text is common attack vector for hackers. 
- if untrusted party can inject JavaScript anywhere in your application then that JS can represent itself as the current user of the application. The attacker can then make requests for sensitive data, monitor activity, and steal credentials.
- Ex below shows how the img element can be used to launch an attack as soon as the page is loaded.
```html
<img src="bogus.png" onerror="console.log('All your base are belong to us')" />
```
- if you are injecting HTML, make sure that it cannot be manipulated by a user. Common injection paths include HTML input controls, URL parameters, and HTTP headers.
- Either sanitize any HTML that contains variables, or simply use DOM manipulation functions instead of using ```innerHTML```

***Event Listeners***
- All DOM elements support the ability to attach a function that gets called when an event occurs on the element. (Event listeners)
- ex:
```js
const submitDataEl = document.querySelector('#submitData');
submitDataEl.addEventListeneer('click', function (event) {
    console.log(event.type);
});
```
- lots of possible events you can add a listener to. includes things like mouse, keyboard, scrolling, animation, video, audio, WebSocket, and clipboard events. 
- Commonly used events:
  - clipboard - cut, copied, pasted
  - focus - an element gets focus
  - keyboard - keys are pressed
  - mouse - click events
  - text selection - when text is selected
- you can add event listeners directly in HTML
```html
<button onclick='alert("clicked")'>click me</button>
```

***Local Storage***
- ```localStorage``` api provides ability to persistently store and retrieve data (ie scores, usernames, etc.) on a user's browser across user sessions and HTML page renderings.
- your frontend JS code could store a user's name on one HTML page, and then retrieve the name later when a different HTML page is loaded.
- same user's name will also be available in local storage the next time the same browser is used to access the same website.
- Also used as a cache for when data cannot be obtained from the server. 
  - ex. frontend JS could store the last high scores obtained from the service, and then display those scores in the future if the service not available.
- four main functions:
  - setItem(name, value) = sets a named item's value into local storage
  - getItem(name) = gets a named item's value from local storage
  - removeItem(name) = removes a named item from local storage
  - clear() = clears all items in local storage.
- objects and arrays need to be converted to a json string using JSON.stringify() on insertion, and JSON.parse() when retrieved.
- in devtools, Application, then Storage > local storage and then your domain name will let you add, view, update, and delete any storage values

***Promise***
- long running or blocking tasks should be executed with the use of JS ```Promise```. 
- allows main rendering thread to continue while some action is executed in background.
- make promise by calling Promise object constructor and passing it an executor function that runs the asynchronous operation.
  - asynchronously means that promise constructor may return before the promise executor function runs.
  - state of promise execution is always in one of three states.
    - pending - running asynchronously
    - fulfilled - completed successfully
    - rejected = failed to complete
- **Resolving and rejecting**
  - Promise executor function takes two functions as parameters, resolve and reject.
  - calling resolve sets promise to fulfilled state, calling reject sets the promise to the rejected state.
```js
const coinToss = new Promise((resolve, reject) => {
  setTimeout(() => {
    if (Math.random() > 0.5) {
      resolve('success');
    } else {
      reject('error');
    }
  }, 10000);
});
```

***Then, Catch, finally***
- promise object has three functions: then, catch, and finally.
  - then function called if promise is fulfilled, catch is called if the promise is rejected, and finally always called after all the processing is completed.
```js
const coinToss = new Promise((resolve, reject) => {
  setTimeout(() => {
    if (Math.random() > 0.1) {
      resolve(Math.random() > 0.5 ? 'heads' : 'tails');
    } else {
      reject('fell off table');
    }
  }, 10000);
});
```
```js
coinToss
  .then((result) => console.log(`Coin toss result: ${result}`))
  .catch((err) => console.log(`Error: ${err}`))
  .finally(() => console.log('Toss completed'));

// OUTPUT:
//    Coin toss result: tails
//    Toss completed
```

***JS Async/await***
- await keyword wraps the execution of a promise and removed the need to chain functions. 
- await expression will block until the promise state moves to 'fulfilled'. or throws exception if the state moves to rejected.
- two ways to do it: then/catch chain version (see above), and async, try/catch version
```js
try {
  const result = await coinToss();
  console.log(`Toss result ${result}`);
} catch (err) {
  console.error(`Error: ${err}`);
} finally {
  console.log(`Toss completed`);
}
```
- **ASYNC**
  - a restriction with await is you cannot call await unless it is called at the top level of the JS, or is in a function that is defined with the async keyword.
  - applying async keyword transforms the function so that it returns a promise that will resolve to the value that was previously returned by the function. 
    - turns any function into asynchronous function, so that it can in turn make asynchronous requests
```js
async function cow() {
    return 'moo';
}
console.log(cow());
// OUTPUT: Promise {<fulfilled>: 'moo'}
```
  - we can change it to explicitly create a promise instead of the auto generated promise that the await keyword generates.
```js
async function cow() {
  return new Promise((resolve) => {
    resolve('moo');
  });
}
console.log(cow());
// OUTPUT: Promise {<pending>}
```

- **AWAIT**
  - async declares that a function returns a promise. 
  - await wraps a call to the async function, blocks execution until the promise has resolved, and then returns the result of the promise.
```js
console.log(cow());
// OUTPUT: Promise {<pending>}

console.log(await cow());
// OUTPUT: moo
```
- **TOGETHER**
  - by combining async to define functions that return promises, with await, to wait on the promise, you can create code that is aysynchronous, but still maintains the flow of the code without explicitly  using callbacks.
  - promise implementation:
```js
const httpPromise = fetch('https://simon.cs260.click/api/user/me');
const jsonPromise = httpPromise.then((r) => r.json());
jsonPromise.then((j) => console.log(j));
console.log('done');

// OUTPUT: done
// OUTPUT: {email: 'bud@mail.com', authenticated: true}
```
  - with async/await, you can clarify the code intent by hiding the promise syntax, and also make the execution block until the promise is resolved.
```js
const httpResponse = await fetch('https://simon.cs260.click/api/user/me');
const jsonResponse = await httpResponse.json();
console.log(jsonResponse);
console.log('done');

// OUTPUT: {email: 'bud@mail.com', authenticated: true}
// OUTPUT: done
```


***Debugging JS***
- **console debugging**
  - insert console.log functions that output the state of the code as it executes. 
```js
var varCount = 20;
let letCount = 20;

console.log('Initial - var: %d, let: %d', varCount, letCount);

for (var varCount = 1; varCount < 2; varCount++) {
  for (let letCount = 1; letCount < 2; letCount++) {
    console.log('Loop - var: %d, let: %d', varCount, letCount);
  }
}

const h1El = document.querySelector('h1');
h1El.textContent = `Result - var:${varCount}, let:${letCount}`;
console.log('Final - var: %d, let: %d', varCount, letCount);
```
  - you can also type in the names of variables in your console window, and execute js in the console.
- **Browser debugging**
  - source tab can add breakpoints, which will execute when you reload the page

***The internet***
- globally connects independent networks and computing devices
- when devices want to talk to one another it must have an IP address (ex 128.187.16.184 is BYU's)
- symbolic (domain) names usually preferred.
- traceroute console utility lets you see hops in a connection
``` 
➜  traceroute byu.edu

traceroute to byu.edu (128.187.16.184), 64 hops max, 52 byte packets
1  192.168.1.1 (192.168.1.1)  10.942 ms  4.055 ms  4.694 ms
2  * * *
3  * * *
4  192-119-18-212.mci.googlefiber.net (192.119.18.212)  5.369 ms  5.576 ms  6.456 ms
5  216.21.171.197 (216.21.171.197)  6.283 ms  6.767 ms  5.532 ms
6  * * *
7  * * *
8  * * *
9  byu.com (128.187.16.184)  7.544 ms !X *  40.231 ms !X
```
- every route is dynamically calculated.
- TCP/IP model is a layered architecture that covers everything from the physical wires to the data that a web application sends
  - top layer is application layer, represents user functionality, such as web, mail, files, remote shell, and chat.
  - next is transport layer which breaks application layer's information into small chunks and sends the data. 
  - actual connection made using internet layer
  - last is link layer which deals with the physical connections and hardware.
  - | Layer	      | Example	         | Purpose                               |
    |-------------|------------------|---------------------------------------|
    | Application | HTTPS	           | Functionality like web browsing       |
    | Transport	  | TCP	             | Moving connection information packets |
    | Internet	   | IP	              | Establishing connections              |
    | Link	       | Fiber, hardware	 | Physical connections                  |

***Web Servers***
- computing device that is hosting a web service that knows how to accept incoming internet connections and speak the HTTP application protocol.
- today most modern programming languages include libraries that provide the ability to make connections and serve up HTTP. 
- ex. ```go```
```js
package main

import (
        "net/http"
        )

func main() {
  // Serve up files found in the public_html directory
  fs := http.FileServer(http.Dir("./public_html"))
  http.Handle("/", fs)

  // Listen for HTTP requests
  http.ListenAndServe(":3000", nil)
}
```
- being able to easily create web services makes it easy to completely drop the monolithic web server concept and just build web services right into your web application.
- we can add function that responds with the current time, when the /api/time resource is requested.
```js
package main

import (
	"fmt"
	"io"
	"net/http"
	"time"
)

func getTime(w http.ResponseWriter, r *http.Request) {
	io.WriteString(w, time.Now().String())
}

func main() {
	// Serve up files found in the public_html directory
	fs := http.FileServer(http.Dir("./public_html"))
	http.Handle("/", fs)

	// Dynamically provide data
	http.HandleFunc("/api/time", getTime)

	// Listen for HTTP requests
	fmt.Println(http.ListenAndServe(":3000", nil))
}
```
- gateways (simple web service) listen on the common HTTPS port 443, looks at the request and maps it to the other services running on different ports
- we use caddy
- microservices are web services that provide a single functional purpose
  - by partitioning functionality into small logical chunks, you can develop and manage them independently of other functionality in a larger system.
  - they can also handle large fluctuations in user demand by simply running more and more stateless copies of the microservice from multiple virtual servers hosted in a dynamic cloud environment.
  - ex one microservice for generating your genealogical family tree might be able to handle 1000 users concurrently, so in order to support 1 million users, you just deploy 1000 instances of the service running on scalable virtual hardware
- serverless
  - evolved from microservices, is where the server is conceptually removed from the architecture, and you just write a function that speaks HTTP. function loaded through a gateway that maps a web request to the function
  - gateway automatically scales the hardware needed to host the serverless function based on demand. This reduces what the web application developer needs to think about down to a single independent function.

***Domain names***
- you can get the ip address for any domain using dig console utility.
- sometimes there are multiple ip addresses with one domain name, allows for redundancy in case if address failing to resolve.
- Top-level-domain (TLD) represents things after dot. (com, edu, click)
- root domain would look like "byu.edu", "google.com", or "cs260.click".
- you can find more information by using whois console utility
- DNS (Domain name service) allows you to associate a domain name with an ip address, but you have to also lease the ip address before you can use it to uniquely identify a device on the internet
- main records that facilitate mapping domain names to IP addresses:
  - address (A) - straight mapping form domain name to IP address
  - canonical name (CNAME) - maps one domain name to another domain name. acts as a domain name alias. would use to map byu.com to the same ip as byu.edu.\
- when entering domain name into browser:
  - browser checks if it's in the cache, and if not, contacts DNS server and gets IP address. DNS server also keeps a cache of names. 
  - if not in that cache, will request name from an authoritative name server. if no recognition there you will get an unknown domain name error.
  - if process resolves, browser makes the HTTP connection to associated IP address.
- Leasing a domain name:
  - you can pay to lease an unused domain name for a specific period of time. before it expires, you can choose to extend.
  - varies from 3 to 200 a year.
  - buying or subleasing from a private party can be very expensive, and you are better off buying something obscure. One reason why companies have such strange names these days.
***Web services intro***
- from frontend JS we can make requests to external services running anywhere in the world. 
- This allows us to get external data that we then inject into the DOM for the user to read. To make a web service request, we supply the URL of the web service to the fetch function that is built into the browser.
- 